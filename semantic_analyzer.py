import re 
import sys
from Lexical_Analyzer import Token, Lexer 
from syntax_analyzer import Node, Parser 

class SemanticError(Exception):
    def __init__(self, message, token):
        self.message = message
        self.token = token
        line = getattr(token, 'line', 'N/A')
        column = getattr(token, 'column', 'N/A')
        value = getattr(token, 'value', '')
        ttype = getattr(token, 'type', 'UNKNOWN')
        super().__init__(f"Semantic Error at Line {line}, Column {column}: {message} (Token: '{value}', Type: {ttype})")

# Represents a single entry in the symbol table (e.g., a variable or function).
class SymbolTableEntry:
    def __init__(self, name, type, kind, declaration_token, params=None, return_type=None):
        self.name = name
        self.type = type
        self.kind = kind # e.g., 'variable', 'function'
        self.declaration_token = declaration_token
        self.params = params if params is not None else []
        self.return_type = return_type

    def __repr__(self):
        return f"Entry(Name: {self.name}, Type: {self.type}, Kind: {self.kind}, Declared: L{self.declaration_token.line} C{self.declaration_token.column})"


# Manages scopes and symbols. A list of dictionaries is used to represent nested scopes.
class SymbolTable:
    def __init__(self):
        self.scopes = [{}] # The global scope is the first entry

    # Called when entering a new scope (e.g., a '{' block).
    def enter_scope(self):
        self.scopes.append({})

    # Called when exiting a scope (e.g., a '}' block).
    def exit_scope(self):
        if len(self.scopes) > 1:
            self.scopes.pop()

    # Adds a new symbol to the current (innermost) scope.
    # Enforces the 'no duplicate declaration' rule for the current scope.
    def declare(self, name, entry):
        current_scope = self.scopes[-1]
        if name in current_scope:
            prev_entry = current_scope[name]
            raise SemanticError(
                f"Identifier '{name}' already declared in this scope at Line {prev_entry.declaration_token.line}",
                entry.declaration_token
            )
        current_scope[name] = entry

    # Searches for a symbol starting from the innermost scope and moving outwards.
    # Enforces the 'use before declare' rule.
    def lookup(self, name, token_for_error):
        for scope in reversed(self.scopes):
            if name in scope:
                return scope[name]
        raise SemanticError(f"Identifier '{name}' not declared", token_for_error)
    
    # New method to display the symbol table contents.
    def display(self):
        lines = []
        for i, scope in enumerate(self.scopes):
            lines.append(f"--- Scope Level {i} ---")
            if not scope:
                lines.append("  (empty)")
                continue
            for name, entry in scope.items():
                lines.append(f"  '{name}': {entry}")
        return "\n".join(lines)


# This class implements a Syntax-Directed Semantic Analyzer.
# It works by traversing the Abstract Syntax Tree (AST) generated by the parser.
# The traversal is implemented using the Visitor design pattern, where each `visit_...`
# method is responsible for checking the semantic rules for a specific AST node type.
class SemanticAnalyzer:
    def __init__(self):
        # The symbol table to store variable and function declarations.
        self.symbol_table = SymbolTable()
        # A list to collect all semantic errors found.
        self.errors = []
        # The set of all valid data types in the language.
        self.defined_types = {'AMint', 'AMchar', 'AMfloat', 'AMbool', 'AMstring', 'AMdouble'}
        # The set of types that are allowed inside conditional statements (if, while).
        # Allowing numeric types is common practice (0 is false, non-zero is true).
        self.conditional_types = {'AMbool', 'AMint', 'AMfloat', 'AMdouble'}

    # Helper function to create and store a semantic error.
    def add_error(self, message, token):
        if not isinstance(token, Token):
            token = Token('UNKNOWN', 'error_location', 0, 0)
        err = SemanticError(message, token)
        self.errors.append(err)
        
    # New method to display the symbol table upon successful analysis.
    def display_symbol_table(self):
        print("\n--- Symbol Table ---")
        print(self.symbol_table.display())

    # The main entry point for the analyzer.
    # It initializes the state and starts the AST traversal.
    def analyze(self, ast_root):
        self.errors = []
        self.symbol_table = SymbolTable() 
        try:
            if ast_root and hasattr(ast_root, 'children') and ast_root.children: 
                self.visit(ast_root)
        except SemanticError as e:
            if e not in self.errors: 
                self.errors.append(e)
        except Exception as e:
            fallback_token = Token('UNKNOWN', str(e), 0, 0)
            self.add_error(f"Unexpected analysis error: {type(e).__name__} - {e}", fallback_token)

        # Report results based on whether errors were found.
        if not self.errors:
            # Success Case
            print("Semantic analysis completed successfully.")
            # Fulfill the requirement to display the symbol table on success.
            self.display_symbol_table()
            return True
        else:
            # Error Case
            print("\nSemantic analysis completed with errors:")
            for error in self.errors:
                print(error)
            return False

    # This is the dispatcher for the Visitor pattern.
    # It takes a node and calls the appropriate `visit_<NodeType>` method.
    def visit(self, node):
        method_name = f'visit_{node.node_type}'
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    # A fallback visitor for node types that don't have a specific semantic check.
    def generic_visit(self, node):
        for child in node.children:
            self.visit(child)
        return "UNKNOWN_TYPE" 

    # Visitor for the top-level program node.
    def visit_PROGRAM(self, node):
        for child_statement in node.children:
            self.visit(child_statement)

    # Visitor for declaration nodes.
    # Enforces two rules:
    # 1. The data type must be a known, defined type.
    # 2. The variable must not have been previously declared in the current scope.
    def visit_DECLARATION(self, node):
        type_node = node.children[0]
        identifier_node = node.children[1]
        var_type = type_node.value
        var_name = identifier_node.value
        declaration_token = identifier_node.token
        
        if var_type not in self.defined_types:
            self.add_error(f"Unknown type '{var_type}'", type_node.token)
            return
            
        entry = SymbolTableEntry(var_name, var_type, "variable", declaration_token)
        try:
            self.symbol_table.declare(var_name, entry)
        except SemanticError as e:
            self.errors.append(e) 

    # Visitor for assignment statements.
    # Enforces type compatibility between the variable and the expression.
    def visit_ASSIGNMENT(self, node):
        identifier_node = node.children[0]
        expression_node = node.children[1]
        var_name = identifier_node.value
        
        try:
            var_entry = self.symbol_table.lookup(var_name, identifier_node.token)
            lhs_type = var_entry.type # Type of the variable
            rhs_type = self.visit(expression_node) # Type of the expression

            if rhs_type != 'ERROR_TYPE':
                # Rule: Types must be equal, or it must be a valid up-cast (e.g., int to float).
                if lhs_type != rhs_type and not (lhs_type in ('AMfloat', 'AMdouble') and rhs_type == 'AMint'):
                    self.add_error(f"Type mismatch: Cannot assign type '{rhs_type}' to variable '{var_name}' of type '{lhs_type}'", identifier_node.token)
        except SemanticError as e:
            self.errors.append(e)

    # Visitor for a standalone expression statement (e.g., a function call).
    def visit_EXPRESSION_STATEMENT(self, node):
        self.visit(node.children[0])

    # Visitor for an identifier when it's used in an expression.
    # Enforces the 'use-before-declare' rule by looking up the identifier.
    # Returns the type of the identifier from the symbol table.
    def visit_IDENTIFIER(self, node):
        var_name = node.value
        try:
            entry = self.symbol_table.lookup(var_name, node.token)
            return entry.type
        except SemanticError as e:
            self.errors.append(e)
            return "ERROR_TYPE"

    # Visitors for literals simply return their hardcoded type.
    def visit_INTEGER_LITERAL(self, node):
        return "AMint"

    def visit_STRING_LITERAL(self, node): 
        return "AMstring"
    
    # Visitor for binary expressions (e.g., x + y).
    # Enforces type rules for arithmetic and comparison operators.
    def visit_BINARY_EXPR(self, node):
        left_type = self.visit(node.children[0])
        right_type = self.visit(node.children[1])
        op = node.value
        
        numeric_types = {"AMint", "AMfloat", "AMdouble"}
        if op in {'+', '-', '*', '/'}: 
            if left_type in numeric_types and right_type in numeric_types:
                # Implements type promotion (e.g., int + float results in a float).
                if "AMdouble" in (left_type, right_type): return "AMdouble"
                if "AMfloat" in (left_type, right_type): return "AMfloat"
                return "AMint"
            else:
                self.add_error(f"Arithmetic operator '{op}' requires numeric operands, got '{left_type}' and '{right_type}'", node.token)
                return "ERROR_TYPE"
        
        # For comparison operators (e.g., x > y), the result is always a boolean.
        if node.token.type == 'COMPARISON_OPERATOR':
             return "AMbool"
             
        return "UNKNOWN_TYPE"

    # Visitor for expressions inside parentheses.
    def visit_PARENTHESIZED_EXPR(self, node):
        # The type of a parenthesized expression is the type of the expression inside it.
        return self.visit(node.children[0])

    # Visitor for a code block.
    # Manages variable scope by entering a new scope for '{' and exiting for '}'.
    def visit_BLOCK(self, node):
        self.symbol_table.enter_scope()
        for statement_node in node.children:
            self.visit(statement_node)
        self.symbol_table.exit_scope()

    # Visitor for if statements.
    # Enforces the rule that the condition must be of a boolean-compatible type.
    def visit_IF_STATEMENT(self, node):
        condition_node = node.children[0]
        if_block_node = node.children[1]

        condition_type = self.visit(condition_node)
        if condition_type not in self.conditional_types and condition_type != "ERROR_TYPE":
            self.add_error(f"Condition for 'startIf' statement must be a boolean or numeric type, got '{condition_type}'", getattr(condition_node, 'token', node.token))
        
        self.visit(if_block_node)
        
        if len(node.children) > 2:
            self.visit(node.children[2]) # Visit else/otherIf clause

    def visit_ELSE_CLAUSE(self, node):
        self.visit(node.children[0]) # Visit the block inside the else
        
    # Visitor for while loops.
    # Enforces the rule that the condition must be of a boolean-compatible type.
    def visit_WHILE_LOOP(self, node):
        condition_node = node.children[0]
        loop_body_node = node.children[1]

        condition_type = self.visit(condition_node)
        if condition_type not in self.conditional_types and condition_type != "ERROR_TYPE":
            self.add_error(f"Condition for 'AMwhile' loop must be a boolean or numeric type, got '{condition_type}'", getattr(condition_node, 'token', node.token))

        self.visit(loop_body_node)

# This main block is for standalone testing of the semantic analyzer.
if __name__ == "__main__":
    print("--- AMCoder Semantic Analyzer Testbed ---")
    print("Enter your AMCoder code below. Type 'ENDCODE' on a new line to analyze.")
    print("Type 'EXIT' to quit.")
    
    while True:
        print("\n" + "="*50)
        code_lines = []
        while True:
            try:
                line = input("> ")
                if line.strip().upper() == 'ENDCODE':
                    break
                if line.strip().upper() == 'EXIT':
                    print("Exiting semantic analyzer testbed.")
                    sys.exit(0)
                code_lines.append(line)
            except EOFError:
                print("\nExiting...")
                sys.exit(0)
        
        source_code = "\n".join(code_lines)
        if not source_code.strip():
            print("No code entered. Please try again.")
            continue

        print("\n--- Analyzing Your Code ---")

        # Step 1: Lexical Analysis
        lexer = Lexer()
        tokens = list(lexer.tokenize(source_code))
        
        # Step 2: Syntax Analysis
        parser = Parser(tokens)
        ast = parser.parse()

        if parser.errors:
            print("\nSyntax Errors found, aborting semantic analysis:")
            for error in parser.errors:
                print(f"  - {error}")
            continue
        
        print("\nSyntax analysis successful. AST generated.")
        
        # Step 3: Semantic Analysis
        # The analyze method now handles printing the success message and symbol table.
        semantic_analyzer = SemanticAnalyzer()
        semantic_analyzer.analyze(ast)

        print("\nReady for new input...")

